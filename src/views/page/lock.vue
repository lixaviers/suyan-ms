<template>
    <div class="suyan__home">
        <h1>锁机制<el-button class="suyan__btn__print" type="primary" plain @click="print">打印pdf</el-button></h1><el-divider></el-divider>
        <h3>一、说说线程安全问题</h3>
<p>线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。在Java里，线程安全一般体现在两个方面：</p>
<ol>
<li>多个thread对同一个Java实例的访问(read和modify)不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和HashTable(后者每个方法前都有synchronized关键字)。如果你在操作一个List对象时，其它线程remove一个element，问题就出现了。</li>
<li>每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。</li>
</ol>
<h3>二、volatile实现原理</h3>
<p>用法：volatile通常被比喻成&rdquo;轻量级的synchronized&ldquo;，也就是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量，无法修饰方法及代码块等。volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p>
<p>原理：为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致的问题。但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一个lock前缀的指令，将这个缓存中的变量回写到系统主存中。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p>
<p>volatile与可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其它线程能够立即看得到修改的值。Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。volatile关键字就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p>
<p>volatile与有序性：有序性即程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save有可能被优化成load-&gt;save-&gt;add。这就是有可能存在有序性问题。而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是它可以禁止指令重排优化等。普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行，这就保证了有序性。</p>
<p>volatile与原子性：原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。线程是CPU调度的基本单位，CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。所以，volatile是不能保证原子性的。</p>
<h3>三、Synchronized底层原理</h3>
<p>1、synchronized的特性</p>
<ul>
<li>原子性：所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程中不会被任何因素打断，要么就都不执行。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作都不可被中断，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成读取、计算、赋值几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断(除了已经废弃的stop()方法)，即保证了原子性。<span style="color: #e03e2d;">synchronized保证原子性，volatile不具备原子性。</span></li>
<li>可见性：可见性是指多个线程访问同一个资源时，该资源的状态、值信息等对于其他线程都是可见的。synchronized和volatile都具有可见性，其中synchronize对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。</li>
<li>有序性：Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。</li>
<li>可重入性：synchronized和ReentrantLock都是可重入锁。当一个线程视图操作一个由其它线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。</li>
</ul>
<p>2、用法：synchronized可以修饰静态方法、成员函数，同时还可以直接定义代码块，但是归根结底它上锁的资源只有两类：一个是对象，一个是类。</p>
<p>3、实现：synchronized有两种形式上锁，一个是对方法上锁，一个是构造同步代码块。它们的底层实现其实都一样，在进入同步代码之前先获取锁，获取到锁之后锁的计数器+1，同步代码执行完锁的计数器-1，如果获取失败就阻塞式等待锁的释放。只是它们在同步块识别方式上有所不一样，从class字节码文件可以表现出来，一个是通过方法flags标志，一个是monitorenter和monitorexit指令操作。</p>
<p>4、synchronized锁的底层实现：在理解锁实现原理之前先了解一下Java的对象头和Monitor，在JVM中，对象是分为三部分存在的：对象头、实例数据、对其填充。实例数据和对其填充与synchronized无关，实例数据存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数字的长度，这部分内存按4字节对其；对其填充不是必须部分，由于虚拟机要求对象起始地址必须是8字节的整数倍，对其填充仅仅是为了使字节对其。对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由 Mark Word 和 Class Metadata Address 组成，其中 Mark Word 存储对象的hashCode、锁信息或分代年龄或GC标志等信息，Class Metadata Address 是类型指针指向对象的类元数据，JVM通过该指针确定该对象是哪个类的实例。锁也分不同状态，JDK6之前只有两个状态：无锁、有锁(重量级锁)，而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：无锁状态、偏向锁、轻量级锁、重量级锁。锁的类型和状态在对象头 Mark Word 中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的 Mark Word 数据。每一个锁都对应一个monitor对象，在HotSpot虚拟机中它是由ObjectMonitor实现的(C++实现)。每个对象都存在这一个monitor与之关联，对象与其monitor之间的关系有多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个monitor被某个线程持有后，它便处于锁定状态。ObjectMonitor中有两个队列_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入_EntryList 集合，当线程获取到对象的monitor后进入_Owner 区域并把monitor中的owner变量设置为当前线程，同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
    </div>
</template>

<script>
import Util from '@/libs/util';
export default {
    methods: {
        print() {
            Util.print();
        }
    }
}
</script>