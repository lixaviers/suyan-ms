<template>
    <div class="suyan__home">
        <h1>数据结构<el-button class="suyan__btn__print" type="primary" plain @click="print">打印pdf</el-button></h1><el-divider></el-divider>
        <h3>一、二叉树(Binary Tree)</h3>
<h4>1.1 定义</h4>
<p>二叉树(binary tree)是有限节点集合构成的结构，其结构的递归定义为：</p>
<ul>
<li>三个不相交的节点集合构成，一个作为根节点，一个节点集构成的二叉树作为根节点的左子树，另一个节点集构成的二叉树作为根节点的右子树。</li>
<li>当节点数为零时，表示二叉树为空。</li>
</ul>
<p>所以节点个数为零的空树也是二叉树，二叉树根节点的左、右子树也是二叉树，其结构同样符合以上定义，当左子树为空树时，表示根节点没有左子节点。</p>
<h4>1.2 结构特性</h4>
<p>首先说明下几个概念：</p>
<ul>
<li>根节点：没有父节点的节点。</li>
<li>叶子节点：没有子节点的节点。</li>
<li>节点的度：节点的分支个数，二叉树每个节点的分支个数为0~2.</li>
<li>路径：连接节点和后代子节点之间的不重复边。</li>
<li>节点的深度：从根节点到该节点的路径长。</li>
<li>节点的高度：从该节点到叶子节点的最大路径长。</li>
<li>节点的层数：父节点的层数加一。</li>
<li>数的高度：根节点高度。</li>
<li>数的深度：叶子节点深度的最大值。</li>
</ul>
<p><a href="https://www.jianshu.com/p/d8103efe0b79" target="_blank" rel="noopener">参考文章</a></p>
<h3>二、二叉搜索树(Binary Search Tree)</h3>
<h4>2.1 引子</h4>
<p>二分法的查找过程是：在一个有序的序列中，每次都会选择有效范围中间位置的元素作判断，即每次判断后，都可以排除近一半的元素，直到查找到目标元素或返回不存在，所以n个有序元素构成的序列，查找的时间复杂度为O(log2n)。既然线性结构能够做到查询复杂度为O(log2n)级别，那二叉搜索树产生又有何必要呢？毕竟二叉搜索树的查询复杂度只是介于O(log2n)~O(n)之间，并不存在查询优势。</p>
<h4>2.2 定义</h4>
<p>二叉搜索树是一种节点值之间具有一定数量级次序的二叉树，对于树中每个节点：</p>
<ul>
<li>若其左子树存在，则其左子树中每个节点的值都不大于该节点值。</li>
<li>若其右子树存在，则其右子树中每个节点的值都不小于该节点值。</li>
</ul>
<p>示例：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="https://raw.githubusercontent.com/lixaviers/suyan-ms/main/src/assets/20210226-110712.png" alt="" width="365" height="371" /></p>
<h4>2.3 查询复杂度</h4>
<p>观察二叉搜索树结构可知，查询每个节点需要的比较次数为节点深度加一。如深度为0，节点值为&rdquo;6&ldquo;的根节点，只需要一次比较即可；深度为1，节点值为&rdquo;3&ldquo;的节点，只需要两次比较。即二叉树节点个数确定的情况下，整棵树的高度越低，节点的查询复杂度越低。</p>
<h4>2.4 构造复杂度</h4>
<p>二叉搜索树的构造过程，也就是将节点不断插入到树中适当位置的过程。该操作过程，与查询节点元素的操作基本相同，不同之处在于：</p>
<ul>
<li>查询节点过程是：比较元素值是否相等，相等则返；，不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素；或子节点为空，返回节点不存在。</li>
<li>插入节点的过程是：比较元素值是否相等，相等则返回，表示已存在；不相等则判断大小情况，迭代查询左、右子树，直到找到相等的元素；或子节点为空，则将节点插入该空节点位置。</li>
</ul>
<p>由此可知，单个节点的构造复杂度和查询负责度相同，为O(log2n)~O(n)。</p>
<h4>2.5 删除复杂度</h4>
<p>二叉搜索树的节点删除包括两个过程，查找和删除。查询的过程和查询复杂度已知，这里说明一下删除节点的过程。节点的删除有以下三种情况：</p>
<ol>
<li>待删除节点度为零。该节点为叶子节点(无子树)，可以直接删除。</li>
<li>待删除节点度为一。该节点有一个左子树，删除节点后，为了维持二叉搜索树结构特性，需要将左子树&rdquo;上移&ldquo;到删除的节点位置上。即二叉搜索树中待删除的节点为一时，可以将待删除节点的左子树或右子树&rdquo;上移&ldquo;到删除节点位置上，以此来满足二叉搜索树的结构特性。</li>
<li>待删除节点度为二。该节点既有左子树，也有右子树，删除节点后，为了维持二叉搜索树的结构特性，需要从其左子树中选出一个最大值的节点，以此来满足二叉搜索树的结构特性。因为是左子树最大值的节点，所以节点的度一定是0或者1，所以删除节点的情况就这么转移。</li>
</ol>
<h4>2.6 性能分析</h4>
<p>由以上查询、构造和删除复杂度的分析可知，复杂度皆为O(log2n)~O(n)。下面分析线性结构的三种操作复杂度，以二分法为例：</p>
<ul>
<li>查询复杂度，时间复杂度为O(log2n)，优于二叉搜索树。</li>
<li>元素的插入操作包括两个步骤，查询和插入。查询的复杂度已知，插入后调整元素位置的复杂度为O(n)，即单个元素的构造复杂度为O(n)。</li>
<li>删除操作也包括两个步骤，查询和删除，查询的复杂度已知，删除后调整元素位置的复杂度为O(n)，即单个元素的删除复杂度为O(n)。</li>
</ul>
<p>由此可知，二叉搜索树相对于线性结构，在构造复杂度和删除复杂度方面占优；在查询复杂度方面，二叉搜索树可能类似于斜树，每层上只有一个节点的情况，该情况下查询复杂度不占优势。</p>
<h4>2.7 总结</h4>
<p>二叉搜索树的节点查询、构造和删除性能，与树的高度相关，如果二叉搜索树能够更&rdquo;平衡&ldquo;一些，避免了树结构向线性结构的倾斜，则能够显著降低时间复杂度。二叉搜索树的存储方面，相对于线性结构只需要保存元素值，树中节点需要额外的空间保存节点之间的父子关系，所以在存储消耗上要高于线性结构。</p>
<h3>三、二叉树遍历</h3>
<p>&nbsp;</p>
<h3>四、平衡二叉树</h3>
<p>&nbsp;</p>
<h3>五、哈夫曼树</h3>
<p>&nbsp;</p>
<h3>六、红黑树</h3>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
    </div>
</template>

<script>
import Util from '@/libs/util';
export default {
    methods: {
        print() {
            Util.print();
        }
    }
}
</script>