{"version":3,"sources":["webpack:///./src/views/page/thread.vue?c9c4","webpack:///src/views/page/thread.vue","webpack:///./src/views/page/thread.vue?6bf7","webpack:///./src/views/page/thread.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","attrs","on","print","_m","staticRenderFns","component"],"mappings":"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","file":"public/js/chunk-2d0c032d.dcaa8594.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"suyan__home\"},[_c('h1',[_vm._v(\"线程\"),_c('el-button',{staticClass:\"suyan__btn__print\",attrs:{\"type\":\"primary\",\"plain\":\"\"},on:{\"click\":_vm.print}},[_vm._v(\"打印pdf\")])],1),_c('el-divider'),_c('h3',[_vm._v(\"一、线程的生命周期(状态)\")]),_vm._m(0),_vm._m(1),_c('h3',[_vm._v(\"二、创建线程池\")]),_vm._m(2),_c('h3',[_vm._v(\"三、线程池核心参数，工作原理\")]),_c('h4',[_vm._v(\"3.1 核心参数\")]),_c('p',[_vm._v(\"我们可以通过ThreadPoolExecutor来创建一个线程池。\")]),_vm._m(3),_c('p',[_vm._v(\"创建一个线程池输入几个参数：\")]),_vm._m(4),_c('h4',[_vm._v(\"3.2 向线程池提交任务\")]),_c('p',[_vm._v(\"我们可以使用execute提交任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。\")]),_vm._m(5),_c('p',[_vm._v(\"我们也可以使用submit方法来提交任务，它会返回一个future，可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成。而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。\")]),_vm._m(6),_c('h4',[_vm._v(\"3.3 线程池的关闭\")]),_c('p',[_vm._v(\"可以通过调用线程池的shutdown和shutdownNow方法来关闭线程池，但是它们的实现原理不同，shutdown的原理只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。\")]),_c('p',[_vm._v(\"只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特效决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。\")]),_c('h4',[_vm._v(\"3.4 线程池的分析\")]),_c('p',[_vm._v(\"线程池的只要工作流程如下图：\")]),_c('p'),_c('p'),_c('p'),_c('p'),_c('p'),_c('p')],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"新建(new Thread)：当创建一个Thread类的一个实例时，此线程进入新建状态(未被启动)。\")]),_c('li',[_vm._v(\"就绪(runnable)：线程已经被启动，正在等待分配CPU时间片，也就是说此时线程正在就绪队列中排队等待得到CPU资源。例如：t1.start()。\")]),_c('li',[_vm._v(\"运行(running)：线程获得CPU资源正在执行任务(run())，此时除非线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。\")]),_c('li',[_vm._v(\"死亡(dead)：当线程执行完毕或被其它线程杀死，线程进入死亡状态，这时线程不可能再进入就绪状态等待执行。自然终止：正常运行run()方法后终止。异常终止：调用stop()终止运行。\")]),_c('li',[_vm._v(\"堵塞(blocked)：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。正在睡眠：用sleep()方法可使线程进入睡眠状态，一个睡眠着的线程在指定的时间过去可进入就绪状态。正在等待：调用wait()方法(调用motify()方法回到就绪状态)。被另一个线程所阻塞：调用suspend()方法(调用resume()方法恢复)。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_c('a',{attrs:{\"href\":\"https://www.cnblogs.com/langjunnan/p/6444718.html\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"参考文章\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"newFixedThreadPool(int nThreads)：创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最多数量，这时线程规模将不再变化。当线程发送未预期的错误而结束时，线程池会补充一个新的线程。\")]),_c('li',[_vm._v(\"newCachedThreadPool()：创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程。而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。\")]),_c('li',[_vm._v(\"newSignleThreadExecutor()：单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。它的特点是能确保依照任务在队列中的顺序来串行执行。\")]),_c('li',[_vm._v(\"newScheduledThreadPool(int corePoolSize)：创建一个固定长度的线程池，而且以低延迟或者定时的方式来执行任务，类似于Timer。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',{staticClass:\"language-java\"},[_c('code',[_vm._v(\"new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \\nBlockingQueue<Runnable> workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程。等到需要执行的任务树大于线程池基本大小时就不在创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\")]),_c('li',[_vm._v(\"maximumPoolSize(线程池最大大小)：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数大于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。\")]),_c('li',[_vm._v(\"keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\")]),_c('li',[_vm._v(\"timeUnit(线程活动保持时间的单位)：可选的单位有天(DAYS)，小时(HOURS)，分钟(MINUTES)，毫秒(MILLISECONDS)，微秒(MICROSECONDS，千分之一毫秒)和毫微秒(NANOSECONDS，千分之一微秒)。\")]),_c('li',[_vm._v(\"workQueue(任务队列)：用于保存等待执行的任务的阻塞队列。可选以下几个阻塞队列：\")]),_c('ol',[_c('li',[_vm._v(\"ArrayBlockingQueue：一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序。\")]),_c('li',[_vm._v(\"LinkedBlockQueue：一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)原则排序，吞吐量通常要高于ArrayBlockQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。\")]),_c('li',[_vm._v(\"SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockQueue。静态工厂方法Executors.newCachedThreadPool使用了这个队列。\")])]),_c('li',[_vm._v(\"threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建处理的线程设置更有意义的名字，Debug和定位问题时非常有帮助。\")]),_c('li',[_vm._v(\"RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。JDK1.5提供了四种策略：\")]),_c('ol',[_c('li',[_vm._v(\"AbortPolicy：直接抛出异常。\")]),_c('li',[_vm._v(\"CallerRunsPolicy：只用调用者所在线程来运行任务。\")]),_c('li',[_vm._v(\"DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\")]),_c('li',[_vm._v(\"DiscardPolicy：不处理，丢弃掉。\")]),_c('li',[_vm._v(\"也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\")])])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',{staticClass:\"language-java\"},[_c('code',[_vm._v(\"threadsPool.execute(new Runnable() {\\n\\t@Override\\n\\tpublic void run() {\\n\\t// TODO Auto-generated method stub\\n\\t}\\n});\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',{staticClass:\"language-java\"},[_c('code',[_vm._v(\"try {\\n\\tObject s = future.get();\\n} catch (InterruptedException e) {\\n\\t// 处理中断异常\\n} catch (ExecutionException e) {\\n\\t// 处理无法执行任务异常\\n} finally {\\n\\t// 关闭线程池\\n\\texecutor.shutdown();\\n}\")])])}]\n\nexport { render, staticRenderFns }","<template>\n    <div class=\"suyan__home\">\n        <h1>线程<el-button class=\"suyan__btn__print\" type=\"primary\" plain @click=\"print\">打印pdf</el-button></h1><el-divider></el-divider>\n        <h3>一、线程的生命周期(状态)</h3>\n<ol>\n<li>新建(new Thread)：当创建一个Thread类的一个实例时，此线程进入新建状态(未被启动)。</li>\n<li>就绪(runnable)：线程已经被启动，正在等待分配CPU时间片，也就是说此时线程正在就绪队列中排队等待得到CPU资源。例如：t1.start()。</li>\n<li>运行(running)：线程获得CPU资源正在执行任务(run())，此时除非线程自动放弃CPU资源或者有优先级更高的线程进入，线程将一直运行到结束。</li>\n<li>死亡(dead)：当线程执行完毕或被其它线程杀死，线程进入死亡状态，这时线程不可能再进入就绪状态等待执行。自然终止：正常运行run()方法后终止。异常终止：调用stop()终止运行。</li>\n<li>堵塞(blocked)：由于某种原因导致正在运行的线程让出CPU并暂停自己的执行，即进入堵塞状态。正在睡眠：用sleep()方法可使线程进入睡眠状态，一个睡眠着的线程在指定的时间过去可进入就绪状态。正在等待：调用wait()方法(调用motify()方法回到就绪状态)。被另一个线程所阻塞：调用suspend()方法(调用resume()方法恢复)。</li>\n</ol>\n<p><a href=\"https://www.cnblogs.com/langjunnan/p/6444718.html\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n<h3>二、创建线程池</h3>\n<ul>\n<li>newFixedThreadPool(int nThreads)：创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最多数量，这时线程规模将不再变化。当线程发送未预期的错误而结束时，线程池会补充一个新的线程。</li>\n<li>newCachedThreadPool()：创建一个可缓存的线程池，如果线程池的规模超过了处理需求，将自动回收空闲线程。而当需求增加时，则可以自动添加新线程，线程池的规模不存在任何限制。</li>\n<li>newSignleThreadExecutor()：单线程的Executor，它创建单个工作线程来执行任务，如果这个线程异常结束，会创建一个新的来替代它。它的特点是能确保依照任务在队列中的顺序来串行执行。</li>\n<li>newScheduledThreadPool(int corePoolSize)：创建一个固定长度的线程池，而且以低延迟或者定时的方式来执行任务，类似于Timer。</li>\n</ul>\n<h3>三、线程池核心参数，工作原理</h3>\n<h4>3.1 核心参数</h4>\n<p>我们可以通过ThreadPoolExecutor来创建一个线程池。</p>\n<pre class=\"language-java\"><code>new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, \nBlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler);</code></pre>\n<p>创建一个线程池输入几个参数：</p>\n<ul>\n<li>corePoolSize(线程池的基本大小)：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程。等到需要执行的任务树大于线程池基本大小时就不在创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。</li>\n<li>maximumPoolSize(线程池最大大小)：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数大于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</li>\n<li>keepAliveTime(线程活动保持时间)：线程池的工作线程空闲后，保持存活的时间。如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>\n<li>timeUnit(线程活动保持时间的单位)：可选的单位有天(DAYS)，小时(HOURS)，分钟(MINUTES)，毫秒(MILLISECONDS)，微秒(MICROSECONDS，千分之一毫秒)和毫微秒(NANOSECONDS，千分之一微秒)。</li>\n<li>workQueue(任务队列)：用于保存等待执行的任务的阻塞队列。可选以下几个阻塞队列：</li>\n<ol>\n<li>ArrayBlockingQueue：一个基于数组结构的有界阻塞队列，此队列按FIFO(先进先出)原则对元素进行排序。</li>\n<li>LinkedBlockQueue：一个基于链表结构的阻塞队列，此队列按FIFO(先进先出)原则排序，吞吐量通常要高于ArrayBlockQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>\n<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockQueue。静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>\n</ol>\n<li>threadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建处理的线程设置更有意义的名字，Debug和定位问题时非常有帮助。</li>\n<li>RejectedExecutionHandler(饱和策略)：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。JDK1.5提供了四种策略：</li>\n<ol>\n<li>AbortPolicy：直接抛出异常。</li>\n<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>\n<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>\n<li>DiscardPolicy：不处理，丢弃掉。</li>\n<li>也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li>\n</ol>\n</ul>\n<h4>3.2 向线程池提交任务</h4>\n<p>我们可以使用execute提交任务，但是execute方法没有返回值，所以无法判断任务是否被线程池执行成功。</p>\n<pre class=\"language-java\"><code>threadsPool.execute(new Runnable() {\n\t@Override\n\tpublic void run() {\n\t// TODO Auto-generated method stub\n\t}\n});</code></pre>\n<p>我们也可以使用submit方法来提交任务，它会返回一个future，可以通过这个future来判断任务是否执行成功，通过future的get方法来获取返回值，get方法会阻塞住直到任务完成。而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完。</p>\n<pre class=\"language-java\"><code>try {\n\tObject s = future.get();\n} catch (InterruptedException e) {\n\t// 处理中断异常\n} catch (ExecutionException e) {\n\t// 处理无法执行任务异常\n} finally {\n\t// 关闭线程池\n\texecutor.shutdown();\n}</code></pre>\n<h4>3.3 线程池的关闭</h4>\n<p>可以通过调用线程池的shutdown和shutdownNow方法来关闭线程池，但是它们的实现原理不同，shutdown的原理只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。shutdownNow会首先将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表。</p>\n<p>只要调用了这两个关闭方法的其中一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特效决定，通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow。</p>\n<h4>3.4 线程池的分析</h4>\n<p>线程池的只要工作流程如下图：</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n    </div>\n</template>\n\n<script>\nimport Util from '@/libs/util';\nexport default {\n    methods: {\n        print() {\n            Util.print();\n        }\n    }\n}\n</script>","import mod from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/index.js??vue-loader-options!./thread.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/index.js??vue-loader-options!./thread.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./thread.vue?vue&type=template&id=dc6f057c&\"\nimport script from \"./thread.vue?vue&type=script&lang=js&\"\nexport * from \"./thread.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}