(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d229dd5"],{deec:function(e,t,r){"use strict";r.r(t);var i=function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("div",{staticClass:"suyan__home"},[r("h1",[e._v("消息中间件"),r("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:e.print}},[e._v("打印pdf")]),r("el-button",{staticClass:"suyan__btn__close",staticStyle:{"margin-right":"20px"},attrs:{plain:""},on:{click:e.closeAside}},[e._v("关闭导航")])],1),r("el-divider"),r("h3",[e._v("一、为什么要使用MQ？")]),e._m(0),r("h3",[e._v("二、RocketMQ由哪些角色组成，每个角色作用和特点是什么？")]),e._m(1),r("h3",[e._v("三、RocketMQ如何做负载均衡？")]),r("p",[e._v("通过Topic在多Broker中分布式存储实现")]),r("p",[e._v("producer端：发送端指定message queue发送消息到相应的broker，来达到写入时的负载均衡。")]),e._m(2),r("p",[e._v("默认策略是随机选择：")]),e._m(3),r("p",[e._v("其它实现：")]),e._m(4),r("p",[e._v("consumer端：采用的是平均分配算法来进行负载均衡。")]),r("p",[e._v("其它负载均衡算法：")]),e._m(5),r("h3",[e._v("四、如何处理RocketMQ消息重复消费？")]),r("p",[e._v("影响消息正常发送和消费的重要原因是网络的不稳定性。")]),r("p",[e._v("引起重复消费的原因：")]),e._m(6),r("p",[e._v("解决方案：")]),e._m(7),r("h3",[e._v("五、如何让RocketMQ保证消息的顺序消费？")]),r("p",[e._v("多个queue只能保证单个queue里的顺序，queue是典型的FIFO(First Input First Output)先进先出队列，天然顺序。多个queue同时消费是无法绝对保证消息的有序性的。同一个topic，同一个queue，发消息的时候一个线程去发送消息，消费的时候一个线程去消费一个queue里的消息。")]),r("p",[e._v("怎么保证消息发送到同一个queue？")]),r("p",[e._v("RocketMQ给我们提供了MessageQueueSelector接口，可以自己重写里面的接口，实现自己的算法。比如：i % 2 == 0，那就都放到queue1里，否则放到queue2里。")]),r("h3",[e._v("六、RocketMQ如何保证消息不丢失？")]),r("p",[e._v("1、Producer端如何保证消息不丢失")]),e._m(8),r("p",[e._v("2、Broker端如何保证消息不丢失")]),e._m(9),r("p",[e._v("3、Consumer端如何保证消息不丢失")]),e._m(10),r("h3",[e._v("七、RocketMQ的消息堆积如何处理？")]),r("p",[e._v("首先要找到是什么原因导致的消息堆积，是Producer太多了，Consumer太少了导致的还是说其他情况，总之先定位问题。然后看下消息消费速度是否正常，正常的话，可以通过上线更多consumer临时解决消息堆积问题。")]),r("p",[e._v("如果Consumer和Queue不对等，上线了多台也在短时间内无法消费完堆积的消息怎么办？")]),e._m(11),r("p",[e._v("堆积时间过长消息超时了？")]),r("p",[e._v("RocketMQ中的消息只会在commitLog被删除的时候才会消息，不会超时。也就是说未被消费的消息不会存在超时删除的情况。")]),r("p",[e._v("堆积的消息会不会进死信队列？")]),r("p",[e._v("不会，消息在消费失败后会进入重试队列(%RETRY%+ConsumerGroup)，18次(默认)才会进入死信队列(%DLQ%+ConsumerGroup)。")]),r("h3",[e._v("八、RocketMQ在分布式事务支持这块机制的底层原因")]),r("p",[e._v("RocketMQ4.3+提供分布式事务功能，通过RocketMQ事务消息能达到分布式事务的最终一致。")]),r("p",[e._v("RocketMQ实现方式：")]),e._m(12),r("p",[e._v("也就是它并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。")]),r("h3",[e._v("九、RocketMQ是如何保证数据的高容错性的？")]),e._m(13),r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p")],1)},l=[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",{staticStyle:{"border-collapse":"collapse",width:"auto"},attrs:{border:"1"}},[r("tbody",[r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("作用")]),r("td",{staticStyle:{width:"auto"}},[e._v("描述")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("解耦")]),r("td",{staticStyle:{width:"auto"}},[e._v("系统耦合度降低，没有强依赖关系")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("异步")]),r("td",{staticStyle:{width:"auto"}},[e._v("不需要同步执行的远程调用，可以有效提高响应时间")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("削峰")]),r("td",{staticStyle:{width:"auto"}},[e._v("请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮")])])])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("table",{staticStyle:{"border-collapse":"collapse",width:"auto"},attrs:{border:"1"}},[r("tbody",[r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("角色")]),r("td",{staticStyle:{width:"auto"}},[e._v("作用")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("Nameserver")]),r("td",{staticStyle:{width:"auto"}},[e._v("无状态，动态列表；这也是和zk的重要区别之一，zk有状态")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("Producer")]),r("td",{staticStyle:{width:"auto"}},[e._v("消息生产着，负责发消息到Broker")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("Broker")]),r("td",{staticStyle:{width:"auto"}},[e._v("就是MQ本身，负责收发消息、持久化消息等")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[e._v("Consumer")]),r("td",{staticStyle:{width:"auto"}},[e._v("消息消费者，负责从Broker上拉去消息进行消费，消费完进行ack")])])])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("提升写入吞吐量，当多个producer同时向一个broker写入数据的时候，性能会下降。")]),r("li",[e._v("消息分布在多broker中，为负载消费做准备")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("producer维护一个index")]),r("li",[e._v("每次取节点会自增")]),r("li",[e._v("index向所有broker个数取余")]),r("li",[e._v("自带容错策略")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("SelectMessageQueueByHash，hash的是传入的args")]),r("li",[e._v("SelectMessageQueueByRandom")]),r("li",[e._v("SelectMessageQueueByMachineRomm")]),r("li",[e._v("也可以自定义实现MessageQueueSelector接口中的select方法")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("平均分配策略(AllocateMessageQueueAveragely)，默认")]),r("li",[e._v("环形分配策略(AllocateMessageQueueAveragelyByCircle)")]),r("li",[e._v("手动配置分配策略(AllocateMessageQueueByConfig)")]),r("li",[e._v("机房分配策略(AllocateMessageQueueByMachineRoom)")]),r("li",[e._v("一致性哈希分配策略(AllocateMessageQueueConsistentHash)")]),r("li",[e._v("靠近机房策略(AllocateMachineRoomNearby)")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("ACK：正常情况下在consumer真正消费完消息后应该发送ack，通知Broker该消息已正常消费，从queue中剔除。当ack因为网络原因无法发送到Broker，Borker会认为此消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer。")]),r("li",[e._v("消费模式：在CLUSTERING模式下，消息在Broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次。")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("数据库表：处理消息钱，使用消息主键在表中带有约束的字段中insert")]),r("li",[e._v("Map：单机时可以使用map")]),r("li",[e._v("Redis：分布式锁")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("采用send()同步发消息，发送接口是同步感知的")]),r("li",[e._v("发送失败后可以重试，设置重试次数，默认3次。producer.setRetryTimesWhenSendFailed(10);")]),r("li",[e._v("集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("修改刷盘策略为同步刷盘。默认情况下是异步刷盘。flushDiskType=SYNC_FLUSH")]),r("li",[e._v("集群部署，主从模式，高可用")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("完全消费正常后在进行手动ack确认")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("准备一个临时的topic")]),r("li",[e._v("queue的数据是堆积的几倍")]),r("li",[e._v("queue分布到多broker中")]),r("li",[e._v("上线一台Consumer做消息的搬运工，把原来Topic中的消息挪到新的Topic里，不做业务逻辑处理，只是挪过去")]),r("li",[e._v("上线N台Consumer同时消费临时Topic中的数据")]),r("li",[e._v("修改bug")]),r("li",[e._v("恢复原来的Consumer，继续消费之前的Topic")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("Half Message：预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中。")]),r("li",[e._v("检查事务状态：broker会开始一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态(提交、回滚、未知)，如果是未知，broker会定时去回调重新检查。")]),r("li",[e._v("超时：如果超过回查次数，默认回滚消息。")])])},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ul",[r("li",[e._v("在不开启容错的情况下，轮询队列进行发送，如果失败了，重试的时候过滤失败的Broker。")]),r("li",[e._v("如果开启了容错策略，会通过RocketMQ的预测机制来预测一个Broker是否可用。")]),r("li",[e._v("如果上次失败的Broker可用那么还是选择该Broker队列。")]),r("li",[e._v("如果上述情况失败，则随机选择一个进行发送。")]),r("li",[e._v("在发送消息的时候会记录一下调用的时间与是否报错，根据该时间去预测Broker的可用时间。")])])}],_=r("c276"),u={methods:{print:function(){_["a"].print()},closeAside:function(){_["a"].closeAside()}}},c=u,s=r("5d22"),o=Object(s["a"])(c,i,l,!1,null,null,null);t["default"]=o.exports}}]);
//# sourceMappingURL=chunk-2d229dd5.fa25ffdb.js.map