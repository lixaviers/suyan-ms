(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0cf4c2"],{"62b2":function(n,t,e){"use strict";e.r(t);var i=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"suyan__home"},[e("h1",[n._v("MySQL"),e("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:n.print}},[n._v("打印pdf")])],1),e("el-divider"),e("h3",[n._v("一、常见的查询算法")]),e("p",[n._v("1、顺序查找(Linear search)：最基本的查询算法当然是顺序查找，也就是对比每个元素的方法，不过这种算法在数据量很大时效率是极低的。")]),e("p",[n._v("2、二分查找(binary search)：比顺序查找更快的查询方法应该就是二分查找了，二分查找的原理是查找过程从数据的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数据大于或小于中间元素的那一半中查找，而且跟开始一样从中间开始比较。如果在某一步骤数据为空，则代表找不到。")]),e("p",[n._v("3、二叉排序树查找：特点是：")]),n._m(0),e("p",[n._v("搜索的原理：")]),n._m(1),e("p",[n._v("4、哈希散列法(哈希表)：首先根据key值和哈希函数创建一个哈希表(散列表)，然后根据键值，通过散列函数，定位数据元素位置。")]),e("p",[n._v("5、分块查找(索引顺序查找)：它是顺序查找的一种改进方法。其算法思想是将n个数据元素”按块有序“划分为m块(m ≤ n)。每一个块中的节点不必有序，但块与块之间必须”按块有序“；即第1块中任意元素的关键字都必须小于第二块中任意元素的关键字；而第2块中任意元素又都必须小于第3块中的任意元素，以此类推。算法流程：")]),n._m(2),e("p",[n._v("6、")]),e("p"),e("p"),e("p"),e("p")],1)},_=[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("若它的左子树不空，则左子树上所有结点的值均小于它的根节点的值；")]),e("li",[n._v("若它的右子树不空，则右子树上所有结点的值均大于它的根节点的值；")]),e("li",[n._v("它的左、右子树也分别为二叉排序树(递归实现)；")])])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("查找操作从根节点开始，一个一个节点递归查找。")]),e("li",[n._v("若该节点的值与要找的值吻合，那么找到退出。")]),e("li",[n._v("若要找的值大于该节点的值，查找它的右子树节点。")]),e("li",[n._v("若要找的值小于该节点的值，查找它的左子树节点。")]),e("li",[n._v("若该节点是NULL，那么说明已经查找完了整个树，还没有找到。")])])},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ul",[e("li",[n._v("先选取各块中的最大关键字构成一个索引表。")]),e("li",[n._v("查找分为两个部分：先对索引表进行二分查找或者顺序查找，以确定待查记录在哪一块中。然后在已确定的块中用顺序法进行查找。")])])}],l=e("c276"),r={methods:{print:function(){l["a"].print()}}},c=r,a=e("5d22"),v=Object(a["a"])(c,i,_,!1,null,null,null);t["default"]=v.exports}}]);
//# sourceMappingURL=chunk-2d0cf4c2.218d8b80.js.map