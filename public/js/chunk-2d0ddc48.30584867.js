(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0ddc48"],{8390:function(r,i,o){"use strict";o.r(i);var n=function(){var r=this,i=r.$createElement,o=r._self._c||i;return o("div",{staticClass:"suyan__home"},[o("h1",[r._v("JVM"),o("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:r.print}},[r._v("打印pdf")])],1),o("el-divider"),o("p",[r._v("一、内存区域")]),o("p",[r._v("1、JVM规范《The Java Virtual Machine Specificati1on, Java SE 8 Edition》2.5 Run-Time Data Areas中描述的运行时数据区分为6个区域")]),r._m(0),o("p",[r._v("二、JVM内存为什么要分成新生代、老年代、持久代，新生代中为什么要分为Eden和Servivor？")]),o("p",[r._v("1、新生代:")]),o("p",[r._v("新生代主要用来存放新生的对象。一般占据堆空间的1/3。在新生代中，保存着大量的刚刚创建的对象，但是大部分的对象都是朝生夕死，所以在新生代中会频繁的进行MinorGC，进行垃圾回收。新生代又细分为三个区：Eden区、SurvivorFrom、SurvivorTo区，三个区的默认比例为8：1：1。")]),r._m(1),o("p",[r._v("2、老年代")]),o("p",[r._v("老年代主要存放应用中生命周期长的内存对象。老年代比较稳定，不会频繁的进行MajorGC。而在MajorGC之前才会先进行一次MinorGC，使得新生的对象进入老年代而导致空间不够才会触发。当无法找到足够大的连续分配给新创建的较大对象也会提前触发一次MajorGC，进行垃圾回收腾出空间。")]),o("p",[r._v("在老年代中，MajorGC采用了标记-清除算法：首先扫描一次所有老年代里的对象，标记处存活的对象，然后回收没有标记的对象。MajorGC的耗时比较长。因为要扫描再回收。MajorGC会产生内存碎片，当老年代也没有内存分配给新来的对象的时候，就会抛出OOM(Out of Memory)异常。")]),o("p",[r._v("3、永久代")]),o("p",[r._v("永久代指的是永久保存区域。")]),o("p"),o("p"),o("p")],1)},v=[function(){var r=this,i=r.$createElement,o=r._self._c||i;return o("ul",[o("li",[r._v("程序计数器（The pc Register）：当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有。")]),o("li",[r._v("虚拟机栈（Java Virtual Machine Stacks）：存放基本数据类型、对象的引用、方法出口等，线程私有。")]),o("li",[r._v("堆（Heap）：java内存最大的一块，所有对象实例、数组都存放在堆里，GC回收的地方，线程共享。")]),o("li",[r._v("方法区（Native Method Stacks）：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。回收目标主要是常量池的回收和类型的卸载，各线程共享。")])])},function(){var r=this,i=r.$createElement,o=r._self._c||i;return o("ul",[o("li",[r._v("Eden区：Java新创建的对象绝大部分会分配在Eden区（如果对象太大，则直接分配到老年代）。当Eden区内存不够的时候，就会触发MinorGC（新生代采用的是复制算法），对新生代进行一次垃圾回收。")]),o("li",[r._v("SurvivorFrom区和To区：在GC开始的时候，对象只会存在于Eden区和名为From的Survivor区，To区是空的，一次MinorGC过后，Eden区和SurvivorFrom区存活的对象会移动到SurvivorTo区中，然后会清空Eden区和SurvivorFrom区，并对存活的对象的年龄+1。如果对象的年龄达到15，则直接分配到老年代。MinorGC完成后，SurvivorFrom区和SurvivorTo区的功能进行互换。下一次MinorGC时，会把SurvivorTo区和Eden区存活的对象放入SurvivorFrom区中，并计算对象存活的年龄。")])])}],e=o("c276"),a={methods:{print:function(){e["a"].print()}}},t=a,u=o("5d22"),_=Object(u["a"])(t,n,v,!1,null,null,null);i["default"]=_.exports}}]);
//# sourceMappingURL=chunk-2d0ddc48.30584867.js.map