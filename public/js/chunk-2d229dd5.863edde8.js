(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d229dd5"],{deec:function(t,e,r){"use strict";r.r(e);var i=function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"suyan__home"},[r("h1",[t._v("消息中间件"),r("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:t.print}},[t._v("打印pdf")])],1),r("el-divider"),r("h3",[t._v("一、为什么要使用MQ？")]),t._m(0),r("h3",[t._v("二、RocketMQ由哪些角色组成，每个角色作用和特点是什么？")]),t._m(1),r("h3",[t._v("三、RocketMQ如何做负载均衡？")]),r("p"),r("h3",[t._v("四、如何处理RocketMQ消息重复消费？")]),r("p",[t._v("影响消息正常发送和消费的重要原因是网络的不稳定性。")]),r("p",[t._v("引起重复消费的原因：")]),t._m(2),r("p",[t._v("解决方案：")]),t._m(3),r("h3",[t._v("五、如何让RocketMQ保证消息的顺序消费？")]),r("p",[t._v("多个queue只能保证单个queue里的顺序，queue是典型的FIFO，天然顺序。多个queue同时消费是无法绝对保证消息的有序性的。同一个topic，同一个queue，发消息的时候一个线程去发送消息，消费的时候一个线程去消费一个queue里的消息。")]),r("p",[t._v("怎么保证消息发送到同一个queue？")]),r("p",[t._v("RocketMQ给我们提供了MessageQueueSelector接口，可以自己重写里面的接口，实现自己的算法。比如：i % 2 == 0，那就都放到queue1里，否则放到queue2里。")]),r("h3",[t._v("六、RocketMQ如何保证消息不丢失？")]),r("p",[t._v("1、Producer端如何保证消息不丢失")]),t._m(4),r("p",[t._v("2、Broker端如何保证消息不丢失")]),t._m(5),r("p",[t._v("3、Consumer端如何保证消息不丢失")]),t._m(6),r("h3",[t._v("七、RocketMQ的消息堆积如何处理？")]),r("p"),r("h3",[t._v("八、RocketMQ在分布式事务支持这块机制的底层原因")]),r("p",[t._v("RocketMQ4.3+提供分布式事务功能，通过RocketMQ事务消息能达到分布式事务的最终一致。")]),r("p",[t._v("RocketMQ实现方式：")]),t._m(7),r("p",[t._v("也就是它并未真正进入Topic的queue，而是用了临时queue来放所谓的half message，等提交事务后才会真正的将half message转移到topic下的queue。")]),r("h3",[t._v("九、RocketMQ是如何保证数据的高容错性的？")]),r("p"),r("p"),r("p"),r("p"),r("p"),r("p"),r("p")],1)},_=[function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",{staticStyle:{"border-collapse":"collapse",width:"auto"},attrs:{border:"1"}},[r("tbody",[r("tr",[r("td",{staticStyle:{width:"80px"}},[t._v("作用")]),r("td",{staticStyle:{width:"auto"}},[t._v("描述")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[t._v("解耦")]),r("td",{staticStyle:{width:"auto"}},[t._v("系统耦合度降低，没有强依赖关系")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[t._v("异步")]),r("td",{staticStyle:{width:"auto"}},[t._v("不需要同步执行的远程调用，可以有效提高响应时间")])]),r("tr",[r("td",{staticStyle:{width:"80px"}},[t._v("削峰")]),r("td",{staticStyle:{width:"auto"}},[t._v("请求达到峰值后，后端service还可以保持固定消费速率消费，不会被压垮")])])])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("table",{staticStyle:{"border-collapse":"collapse",width:"100%"},attrs:{border:"1"}},[r("tbody",[r("tr",[r("td",{staticStyle:{width:"48.8717%"}},[t._v("角色")]),r("td",{staticStyle:{width:"48.948%"}},[t._v("作用")])]),r("tr",[r("td",{staticStyle:{width:"48.8717%"}},[t._v("Nameserver")]),r("td",{staticStyle:{width:"48.948%"}},[t._v("无状态，动态列表；这也是和zk的重要区别之一，zk有状态")])]),r("tr",[r("td",{staticStyle:{width:"48.8717%"}},[t._v("Producer")]),r("td",{staticStyle:{width:"48.948%"}},[t._v("消息生产着，负责发消息到Broker")])]),r("tr",[r("td",{staticStyle:{width:"48.8717%"}},[t._v("Broker")]),r("td",{staticStyle:{width:"48.948%"}},[t._v("就是MQ本身，负责收发消息、持久化消息等")])]),r("tr",[r("td",{staticStyle:{width:"48.8717%"}},[t._v("Consumer")]),r("td",{staticStyle:{width:"48.948%"}},[t._v("消息消费者，负责从Broker上拉去消息进行消费，消费完进行ack")])])])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("ACK：正常情况下在consumer真正消费完消息后应该发送ack，通知Broker该消息已正常消费，从queue中剔除。当ack因为网络原因无法发送到Broker，Borker会认为此消息没有被消费，此后会开启消息重投机制把消息再次投递到consumer。")]),r("li",[t._v("消费模式：在CLUSTERING模式下，消息在Broker中会保证相同group的consumer消费一次，但是针对不同group的consumer会推送多次。")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("数据库表：处理消息钱，使用消息主键在表中带有约束的字段中insert")]),r("li",[t._v("Map：单机时可以使用map")]),r("li",[t._v("Redis：分布式锁")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("采用send()同步发消息，发送接口是同步感知的")]),r("li",[t._v("发送失败后可以重试，设置重试次数，默认3次。producer.setRetryTimesWhenSendFailed(10);")]),r("li",[t._v("集群部署，比如发送失败了的原因可能是当前Broker宕机了，重试的时候会发送到其他Broker上")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("修改刷盘策略为同步刷盘。默认情况下是异步刷盘。flushDiskType=SYNC_FLUSH")]),r("li",[t._v("集群部署，主从模式，高可用")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("完全消费正常后在进行手动ack确认")])])},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ul",[r("li",[t._v("Half Message：预处理消息，当broker收到此类消息后，会存储到RMQ_SYS_TRANS_HALF_TOPIC的消息消费队列中。")]),r("li",[t._v("检查事务状态：broker会开始一个定时任务，消费RMQ_SYS_TRANS_HALF_TOPIC队列中的消息，每次执行任务会向消息发送者确认事务执行状态(提交、回滚、未知)，如果是未知，broker会定时去回调重新检查。")]),r("li",[t._v("超时：如果超过回查次数，默认回滚消息。")])])}],c=r("c276"),l={methods:{print:function(){c["a"].print()}}},s=l,a=r("5d22"),u=Object(a["a"])(s,i,_,!1,null,null,null);e["default"]=u.exports}}]);
//# sourceMappingURL=chunk-2d229dd5.863edde8.js.map