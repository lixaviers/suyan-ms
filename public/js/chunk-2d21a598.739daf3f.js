(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d21a598"],{baad:function(e,a,t){"use strict";t.r(a);var l=function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("div",{staticClass:"suyan__home"},[t("h1",[e._v("锁机制"),t("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:e.print}},[e._v("打印pdf")])],1),t("el-divider"),t("h3",[e._v("一、说说线程安全问题")]),t("p",[e._v("线程安全是指要控制多个线程对某个资源的有序访问或修改，而在这些线程之间没有产生冲突。在Java里，线程安全一般体现在两个方面：")]),e._m(0),t("h3",[e._v("二、volatile实现原理")]),t("p",[e._v("用法：volatile通常被比喻成”轻量级的synchronized“，也就是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量，无法修饰方法及代码块等。volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。")]),t("p",[e._v("原理：为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致的问题。但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一个lock前缀的指令，将这个缓存中的变量回写到系统主存中。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议。缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。")]),t("p",[e._v("volatile与可见性：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其它线程能够立即看得到修改的值。Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。volatile关键字就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。")]),t("p",[e._v("volatile与有序性：有序性即程序执行的顺序按照代码的先后顺序执行。除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load->add->save有可能被优化成load->save->add。这就是有可能存在有序性问题。而volatile除了可以保证数据的可见性之外，还有一个强大的功能，那就是它可以禁止指令重排优化等。普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。禁止指令重排，这就保证了代码的程序会严格按照代码的先后顺序执行，这就保证了有序性。")]),t("p",[e._v("volatile与原子性：原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。线程是CPU调度的基本单位，CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。所以，volatile是不能保证原子性的。")]),t("h3",[e._v("三、Synchronized底层原理")]),t("p",[e._v("1、synchronized的特性")]),e._m(1),t("p"),t("p"),t("p")],1)},i=[function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ol",[t("li",[e._v("多个thread对同一个Java实例的访问(read和modify)不会相互干扰，它主要体现在关键字synchronized。如ArrayList和Vector，HashMap和HashTable(后者每个方法前都有synchronized关键字)。如果你在操作一个List对象时，其它线程remove一个element，问题就出现了。")]),t("li",[e._v("每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。")])])},function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ul",[t("li",[e._v("原子性：所谓原子性就是指一个操作或者多个操作，要么全部执行并且执行的过程中不会被任何因素打断，要么就都不执行。在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作都不可被中断，要么执行，要么不执行。但是像i++、i+=1等操作字符就不是原子性的，它们是分成读取、计算、赋值几步操作，原值在这些步骤还没完成时就可能已经被赋值了，那么最后赋值写入的数据就是脏数据，无法保证原子性。被synchronized修饰的类或对象的所有操作都是原子的，因为在执行操作之前必须先获得类或对象的锁，直到执行完才能释放，这中间的过程无法被中断(除了已经废弃的stop()方法)，即保证了原子性。"),t("span",{staticStyle:{color:"#e03e2d"}},[e._v("synchronized保证原子性，volatile不具备原子性。")])]),t("li",[e._v("可见性：可见性是指多个线程访问同一个资源时，该资源的状态、值信息等对于其他线程都是可见的。synchronized和volatile都具有可见性，其中synchronize对一个类或对象加锁时，一个线程如果要访问该类或对象必须先获得它的锁，而这个锁的状态对于其他任何线程都是可见的，并且在释放锁之前会将对变量的修改刷新到主存中，保证资源变量的可见性，如果某个线程占用了该锁，其他线程就必须在锁池中等待锁的释放。")]),t("li",[e._v("有序性：Java允许编译器和处理器对指令进行重排，但是指令重排并不会影响单线程的顺序，它影响的是多线程并发执行的顺序性。synchronized保证了每个时刻都只有一个线程同步代码块，也就确定了线程执行同步代码块是分先后顺序的，保证了有序性。")]),t("li",[e._v("可重入性：synchronized和ReentrantLock都是可重入锁。当一个线程视图操作一个由其它线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁。通俗一点讲就是说一个线程拥有了锁仍然还可以重复申请锁。")])])}],n=t("c276"),o={methods:{print:function(){n["a"].print()}}},v=o,r=t("5d22"),s=Object(r["a"])(v,l,i,!1,null,null,null);a["default"]=s.exports}}]);
//# sourceMappingURL=chunk-2d21a598.739daf3f.js.map