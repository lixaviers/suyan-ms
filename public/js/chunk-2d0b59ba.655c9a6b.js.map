{"version":3,"sources":["webpack:///./src/views/page/redis.vue?2637","webpack:///src/views/page/redis.vue","webpack:///./src/views/page/redis.vue?3c49","webpack:///./src/views/page/redis.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","staticClass","_v","attrs","on","print","_m","staticRenderFns","component"],"mappings":"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","file":"public/js/chunk-2d0b59ba.655c9a6b.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"suyan__home\"},[_c('h1',[_vm._v(\"Redis\"),_c('el-button',{staticClass:\"suyan__btn__print\",attrs:{\"type\":\"primary\",\"plain\":\"\"},on:{\"click\":_vm.print}},[_vm._v(\"打印pdf\")])],1),_c('el-divider'),_c('h3',[_vm._v(\"一、Redis支持数据类型\")]),_c('p',[_vm._v(\"Redis支持五种数据类型：string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(sorted set：有序集合)。\")]),_vm._m(0),_c('h3',[_vm._v(\"二、Redis是多线程还是单线程的\")]),_c('h4',[_vm._v(\"2.1 Redis6.0之前版本\")]),_c('p',[_vm._v(\"官方表示，因为redis是基于内存的操作，CPU不是瓶颈，瓶颈最有可能是机器内存的大小或者带宽。既然单线程实现容易，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案。\")]),_c('h4',[_vm._v(\"2.2 Redis6.0版本\")]),_c('p',[_vm._v(\"6.0之前使用了单线程，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度，同时可能存在线程切换，甚至加锁解锁、死锁造成的性能损耗。redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。Redis的瓶颈不在CPU，而在内存和网络。内存不够的话，可以加内存或者做数据结构优化和其它优化等，但网络的性能优化才是大头，网络IO的读写在Redis整个执行期间占用了大部分的CPU时间，如果把网络处理这部分做成多线程处理方式，那对整个Redis的性能会有很大的提升。优化方向：\")]),_vm._m(1),_c('p',[_vm._v(\"总结起来，Redis支持多线程主要就是两个原因：\")]),_vm._m(2),_c('p',[_vm._v(\"redis并没有默认开启多多线程，在conf文件进行配置，io-threads-do-reads yes，io-threads 线程数，官方建议：4核的集群建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数，尽量不超过8个。开启多线程后，不会出现线程并发安全问题，redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。\")]),_vm._m(3),_c('h3',[_vm._v(\"三、Redis操作怎么保证原子性\")]),_c('p',[_vm._v(\"对于Redis而已，命令的原子性指的是：一个操作的不可再分，操作要么执行，要么不执行。之所以是原子性，因为是单线程操作。Redis本身提供的所有API都是原子操作，redis中的事务其实是保证批量操作的原子性，多个命令在并发中不一定是原子性。\")]),_c('h3',[_vm._v(\"四、Redis事务\")]),_c('p',[_vm._v(\"Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH四个原语实现的。Redis会将一个事务中的所有命令序列化，然后顺序执行。\")]),_vm._m(4),_vm._m(5),_c('h3',[_vm._v(\"五、什么是Redis持久化？Redis有几种持久化方式？优缺点是什么？\")]),_c('p',[_vm._v(\"持久化就是把内存的数据写到磁盘中去，防止服务器宕机内存数据丢失。Redis提供了两种持久化方式：RDB(默认)、AOF。\")]),_vm._m(6),_c('p',[_vm._v(\"比较：\")]),_vm._m(7),_c('h4',[_vm._v(\"5.1 解释下什么是RESP？有什么特点？\")]),_c('p',[_vm._v(\"RESP，REmote Dictionary Server(远程字段服务)，而Redis的协议规范是Redis Serialization Protocol(Redis序列化协议)，该协议是用于与Redis服务器通信的，用的较多的是Redis-cli通过pipe与Redis服务器联系。协议：客户端以规定格式的形式发送命令给服务器，服务器在执行最后一条命令后，返回结果。\")]),_c('p',[_vm._v(\"RESP是redis客户端和服务端之间使用的一种通讯协议。特点：实现简单、快速解析、可读性好。\")]),_c('h3',[_vm._v(\"六、Redis有哪些架构模式？讲讲各自的特点\")]),_c('h4',[_vm._v(\"6.1 单机版\")]),_c('p',[_vm._v(\"特点：简单。\")]),_c('p',[_vm._v(\"问题：1、内存容量有限。2、处理能力有限。3、无法高可用\")]),_c('h4',[_vm._v(\"6.2 主从复制\")]),_c('p',[_vm._v(\"Redis的复制(replication)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。只要主从服务器之间的网络连接正常，主从数据库两者会具有相同的数据，主服务器就会一直将自己身上的数据更新同步给从服务器，从而一直保证主从服务器的数据相同。\")]),_c('p',[_vm._v(\"特点：\")]),_vm._m(8),_c('p',[_vm._v(\"问题：\")]),_vm._m(9),_c('h4',[_vm._v(\"6.3 哨兵\")]),_c('p',[_vm._v(\"Redis sentinel是一个分布式系统监控redis主从服务器，并在主服务器下线时自动进行故障转移。其中三个特效：\")]),_vm._m(10),_c('p',[_vm._v(\"特点：\")]),_vm._m(11),_c('p',[_vm._v(\"缺点：主从模式，切换需要时间丢数据，没有解决master写的压力。\")]),_c('h4',[_vm._v(\"6.4 集群(proxy型)\")]),_c('p',[_vm._v(\"Twemproxy是一个Twitter开源的一个redis和memcache快速/轻量级代理服务器，Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和redis协议。\")]),_c('p',[_vm._v(\"特点：\")]),_vm._m(12),_c('p',[_vm._v(\"缺点：增加了新的proxy，需要维护其高可用。failover逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预。\")]),_c('h4',[_vm._v(\"6.5 集群(直连型)\")]),_c('p',[_vm._v(\"从redis3.0之后版本支持redis-cluster集群，redis-cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其它所有节点连接。\")]),_c('p',[_vm._v(\"特点：\")]),_vm._m(13),_c('p',[_vm._v(\"缺点：\")]),_vm._m(14),_vm._m(15),_c('p',[_vm._v(\"添加节点：\")]),_c('p',[_vm._v(\"集群创建成功后可以向集群中添加节点，如添加7007节点，执行命令：./redis-trib.rb add-node 127.0.01:7007 \")]),_c('p',[_vm._v(\"查看\")]),_c('h3',[_vm._v(\"七、Redis大key问题\")]),_c('h4',[_vm._v(\"7.1 什么是Redis大key\")]),_vm._m(16),_c('h4',[_vm._v(\"7.2 可能存在Redis大key的业务场景\")]),_vm._m(17),_c('h4',[_vm._v(\"7.3 Redis大key的危害\")]),_c('p',[_vm._v(\"OPS低也会导致内存占用多、流量大。比如一次取走100K的数据，当OPS为1000时，就会产生100M/s的流量。如果为list、hash等数据结构，大量的elements需要多次遍历，多次系统调用拷贝数据消耗时间。主动删除、被动过期删除、数据迁移等，由于处理这一个key时间长，导致服务器发送阻塞。\")]),_c('h4',[_vm._v(\"7.4 如何找出Redis大key\")]),_c('p',[_vm._v(\"redis可使用redis-cli的“--bigkeys”选项查找大key。\")]),_c('p',[_vm._v(\"jimdb管理端，拓扑Tab页，点击实例可以使用Redis大key扫描功能，该功能底层使用scan扫描所有key，会影响实例性能，选择在业务低峰进行。\")]),_c('h4',[_vm._v(\"7.5 如何解决Redis大key问题\")]),_c('p',[_vm._v(\"对于需要整取value的大key，可以尝试将对象分拆成几个key-value，使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平铺到多个实例中，降低对单个实例的IO影响。\")]),_c('p',[_vm._v(\"对于每次需要取部分value的大key，同样可以拆成几个key-value，也可以将这些存储在一个hash中，每个field代表具体属性，使用hget、hmget来获取部分value，使用hset、hmset来更新部分属性。\")]),_c('p',[_vm._v(\"对于value中存储过多元素的key，同样可以将这部分元素拆分。\")]),_c('p',[_vm._v(\"示例：可以固定一个桶数量，比如1W，每次存取的时候，先在本地计算field的hash值，对1W取模，确定field落在哪个key上。\")]),_vm._m(18),_vm._m(19),_c('p')],1)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"string：是redis最基本的类型，一个key对应一个value。最大能存储512MB。\")]),_c('li',[_vm._v(\"hash：是一个键值对集合，是一个string类型的field和value的映射表，hash特别适合用于存储对象。每个hash可以存储2\"),_c('sup',[_vm._v(\"32\")]),_vm._v(\"-1 键值对(40多亿)。\")]),_c('li',[_vm._v(\"list：是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或者尾部(右边)。列表最多可存储2\"),_c('sup',[_vm._v(\"32\")]),_vm._v(\"-1元素(4294967295)。\")]),_c('li',[_vm._v(\"set：redis的set是string类型的无序集合。集合通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。集合中最大的成员数为2\"),_c('sup',[_vm._v(\"32\")]),_vm._v(\"-1。\")]),_c('li',[_vm._v(\"zset：zset和set一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"提高网络IO性能，典型的实现比如使用DPDK来替代内核网络栈的方式。\")]),_c('li',[_vm._v(\"使用多线程充分利用多核。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"可以充分利用服务器CPU资源，目前主线程只能利用一个核。\")]),_c('li',[_vm._v(\"多线程任务可以分摊Redis同步IO读写负荷。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_c('a',{attrs:{\"href\":\"https://www.cnblogs.com/gz666666/p/12901507.html\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"参考文章\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"Redis不支持回滚，Redis在事务失败时不进行回滚，而是继续执行余下的命令。\")]),_c('li',[_vm._v(\"如果在一个事务中的命令出现错误，那么所有的命令都不会执行。\")]),_c('li',[_vm._v(\"如果在一个事物中出现运行错误，那么正确的命令会被执行。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"MULTI命令用于开启一个事物，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令。这些命令不会立即执行，而是被放到一个队列中。当EXEC命令被调用时，所有队列中的命令才会被执行。\")]),_c('li',[_vm._v(\"EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil。\")]),_c('li',[_vm._v(\"通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。\")]),_c('li',[_vm._v(\"WATCH命令可以为Redis事务提供check-and-set(CAS)行为。可以监控一个或多个键，一旦其中有一个键被修改(或删除)，之后的事务就不会执行，监控一直持续到EXEC命令。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"RDB：是Redis DataBase的缩写，功能核心函数rdbSave(生成RDB文件)和rdbLoad(从文件加载内存)两个函数。\")]),_c('li',[_vm._v(\"AOF：是Append-only file的缩写，每当执行服务器(定时)任务或者函数时，flushAppendOnlyFile函数都会被调用，这个函数执行两个工作，aof写入保存：WRITE：根据条件，将aof_buf中的缓存写入到AOF文件。SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中。存储结构是redis通讯协议(RESP)格式的命令文件存储。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"aof文件比rdb更新频率高，优先使用aof还原数据。\")]),_c('li',[_vm._v(\"aof比rdb更安全也更大。\")]),_c('li',[_vm._v(\"rdb性能比aof好。\")]),_c('li',[_vm._v(\"如果两个都配置了优先加载AOF。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"master/slave 角色。\")]),_c('li',[_vm._v(\"master/slave 数据相同。\")]),_c('li',[_vm._v(\"降低master读压力，转交从库。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"无法保证高可用。\")]),_c('li',[_vm._v(\"没有解决master写的压力。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ul',[_c('li',[_vm._v(\"监控(Monitoring)：sentinel会不断地检查你的主服务器和从服务器是否运作正常。\")]),_c('li',[_vm._v(\"提醒(Notification)：当被监控的某个Redis服务器出现问题时，sentinel可以通过API向管理员或者其他应用程序发送通知。\")]),_c('li',[_vm._v(\"自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时，sentinel会开始一次自动故障迁移操作。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"保证高可用。\")]),_c('li',[_vm._v(\"监控各个节点。\")]),_c('li',[_vm._v(\"自动故障迁移。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"多种hash算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins。\")]),_c('li',[_vm._v(\"支持失败节点自动删除。\")]),_c('li',[_vm._v(\"后端Sharding分配逻辑对业务透明，业务方的读写方式和操作单个Redis一致。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"无中心架构(不存在哪个节点影响性能瓶颈)，少了proxy层。\")]),_c('li',[_vm._v(\"数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。\")]),_c('li',[_vm._v(\"可扩展性，可线性扩展到1000个节点，节点可动态添加或删除。\")]),_c('li',[_vm._v(\"高可用性，部分节点不可用时，集群仍可用。通过增加Slave做备份数据副本。\")]),_c('li',[_vm._v(\"实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提示。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"资源隔离性较差，容易出现相互影响的情况。\")]),_c('li',[_vm._v(\"数据通过异步复制，不保证数据的强一致性。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_c('a',{attrs:{\"href\":\"https://www.cnblogs.com/lpfuture/p/5796398.html\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"一致性哈希算法\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"单个key存储的value很大。\")]),_c('li',[_vm._v(\"hash、set、zset、list结构中存储过多的元素。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('ol',[_c('li',[_vm._v(\"配送范围特别大的门店。\")]),_c('li',[_vm._v(\"促销活动特别多的门店、商家等。\")]),_c('li',[_vm._v(\"高频用户下的订单列表。\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('pre',{staticClass:\"language-java\"},[_c('code',[_vm._v(\"newHashKey = hashKey + (hash(field) % 10000);\\nhset(newHashKey, field, value);\\nhget(newHashKey, field);\")])])},function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('p',[_c('a',{attrs:{\"href\":\"https://www.cnblogs.com/xgqfrms/p/13601959.html\",\"target\":\"_blank\",\"rel\":\"noopener\"}},[_vm._v(\"参考文章\")])])}]\n\nexport { render, staticRenderFns }","<template>\n    <div class=\"suyan__home\">\n        <h1>Redis<el-button class=\"suyan__btn__print\" type=\"primary\" plain @click=\"print\">打印pdf</el-button></h1><el-divider></el-divider>\n        <h3>一、Redis支持数据类型</h3>\n<p>Redis支持五种数据类型：string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(sorted set：有序集合)。</p>\n<ul>\n<li>string：是redis最基本的类型，一个key对应一个value。最大能存储512MB。</li>\n<li>hash：是一个键值对集合，是一个string类型的field和value的映射表，hash特别适合用于存储对象。每个hash可以存储2<sup>32</sup>-1 键值对(40多亿)。</li>\n<li>list：是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部(左边)或者尾部(右边)。列表最多可存储2<sup>32</sup>-1元素(4294967295)。</li>\n<li>set：redis的set是string类型的无序集合。集合通过哈希表实现的，所以添加、删除、查找的复杂度都是O(1)。集合中最大的成员数为2<sup>32</sup>-1。</li>\n<li>zset：zset和set一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数，redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的，但分数(score)却可以重复。</li>\n</ul>\n<h3>二、Redis是多线程还是单线程的</h3>\n<h4>2.1 Redis6.0之前版本</h4>\n<p>官方表示，因为redis是基于内存的操作，CPU不是瓶颈，瓶颈最有可能是机器内存的大小或者带宽。既然单线程实现容易，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案。</p>\n<h4>2.2 Redis6.0版本</h4>\n<p>6.0之前使用了单线程，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度，同时可能存在线程切换，甚至加锁解锁、死锁造成的性能损耗。redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。Redis的瓶颈不在CPU，而在内存和网络。内存不够的话，可以加内存或者做数据结构优化和其它优化等，但网络的性能优化才是大头，网络IO的读写在Redis整个执行期间占用了大部分的CPU时间，如果把网络处理这部分做成多线程处理方式，那对整个Redis的性能会有很大的提升。优化方向：</p>\n<ul>\n<li>提高网络IO性能，典型的实现比如使用DPDK来替代内核网络栈的方式。</li>\n<li>使用多线程充分利用多核。</li>\n</ul>\n<p>总结起来，Redis支持多线程主要就是两个原因：</p>\n<ol>\n<li>可以充分利用服务器CPU资源，目前主线程只能利用一个核。</li>\n<li>多线程任务可以分摊Redis同步IO读写负荷。</li>\n</ol>\n<p>redis并没有默认开启多多线程，在conf文件进行配置，io-threads-do-reads yes，io-threads 线程数，官方建议：4核的集群建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数，尽量不超过8个。开启多线程后，不会出现线程并发安全问题，redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。</p>\n<p><a href=\"https://www.cnblogs.com/gz666666/p/12901507.html\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n<h3>三、Redis操作怎么保证原子性</h3>\n<p>对于Redis而已，命令的原子性指的是：一个操作的不可再分，操作要么执行，要么不执行。之所以是原子性，因为是单线程操作。Redis本身提供的所有API都是原子操作，redis中的事务其实是保证批量操作的原子性，多个命令在并发中不一定是原子性。</p>\n<h3>四、Redis事务</h3>\n<p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH四个原语实现的。Redis会将一个事务中的所有命令序列化，然后顺序执行。</p>\n<ul>\n<li>Redis不支持回滚，Redis在事务失败时不进行回滚，而是继续执行余下的命令。</li>\n<li>如果在一个事务中的命令出现错误，那么所有的命令都不会执行。</li>\n<li>如果在一个事物中出现运行错误，那么正确的命令会被执行。</li>\n</ul>\n<ol>\n<li>MULTI命令用于开启一个事物，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令。这些命令不会立即执行，而是被放到一个队列中。当EXEC命令被调用时，所有队列中的命令才会被执行。</li>\n<li>EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值nil。</li>\n<li>通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务，并且客户端会从事务状态中退出。</li>\n<li>WATCH命令可以为Redis事务提供check-and-set(CAS)行为。可以监控一个或多个键，一旦其中有一个键被修改(或删除)，之后的事务就不会执行，监控一直持续到EXEC命令。</li>\n</ol>\n<h3>五、什么是Redis持久化？Redis有几种持久化方式？优缺点是什么？</h3>\n<p>持久化就是把内存的数据写到磁盘中去，防止服务器宕机内存数据丢失。Redis提供了两种持久化方式：RDB(默认)、AOF。</p>\n<ul>\n<li>RDB：是Redis DataBase的缩写，功能核心函数rdbSave(生成RDB文件)和rdbLoad(从文件加载内存)两个函数。</li>\n<li>AOF：是Append-only file的缩写，每当执行服务器(定时)任务或者函数时，flushAppendOnlyFile函数都会被调用，这个函数执行两个工作，aof写入保存：WRITE：根据条件，将aof_buf中的缓存写入到AOF文件。SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中。存储结构是redis通讯协议(RESP)格式的命令文件存储。</li>\n</ul>\n<p>比较：</p>\n<ol>\n<li>aof文件比rdb更新频率高，优先使用aof还原数据。</li>\n<li>aof比rdb更安全也更大。</li>\n<li>rdb性能比aof好。</li>\n<li>如果两个都配置了优先加载AOF。</li>\n</ol>\n<h4>5.1 解释下什么是RESP？有什么特点？</h4>\n<p>RESP，REmote Dictionary Server(远程字段服务)，而Redis的协议规范是Redis Serialization Protocol(Redis序列化协议)，该协议是用于与Redis服务器通信的，用的较多的是Redis-cli通过pipe与Redis服务器联系。协议：客户端以规定格式的形式发送命令给服务器，服务器在执行最后一条命令后，返回结果。</p>\n<p>RESP是redis客户端和服务端之间使用的一种通讯协议。特点：实现简单、快速解析、可读性好。</p>\n<h3>六、Redis有哪些架构模式？讲讲各自的特点</h3>\n<h4>6.1 单机版</h4>\n<p>特点：简单。</p>\n<p>问题：1、内存容量有限。2、处理能力有限。3、无法高可用</p>\n<h4>6.2 主从复制</h4>\n<p>Redis的复制(replication)功能允许用户根据一个Redis服务器来创建任意多个该服务器的复制品，其中被复制的服务器为主服务器(master)，而通过复制创建出来的服务器复制品则为从服务器(slave)。只要主从服务器之间的网络连接正常，主从数据库两者会具有相同的数据，主服务器就会一直将自己身上的数据更新同步给从服务器，从而一直保证主从服务器的数据相同。</p>\n<p>特点：</p>\n<ol>\n<li>master/slave 角色。</li>\n<li>master/slave 数据相同。</li>\n<li>降低master读压力，转交从库。</li>\n</ol>\n<p>问题：</p>\n<ol>\n<li>无法保证高可用。</li>\n<li>没有解决master写的压力。</li>\n</ol>\n<h4>6.3 哨兵</h4>\n<p>Redis sentinel是一个分布式系统监控redis主从服务器，并在主服务器下线时自动进行故障转移。其中三个特效：</p>\n<ul>\n<li>监控(Monitoring)：sentinel会不断地检查你的主服务器和从服务器是否运作正常。</li>\n<li>提醒(Notification)：当被监控的某个Redis服务器出现问题时，sentinel可以通过API向管理员或者其他应用程序发送通知。</li>\n<li>自动故障迁移(Automatic failover)：当一个主服务器不能正常工作时，sentinel会开始一次自动故障迁移操作。</li>\n</ul>\n<p>特点：</p>\n<ol>\n<li>保证高可用。</li>\n<li>监控各个节点。</li>\n<li>自动故障迁移。</li>\n</ol>\n<p>缺点：主从模式，切换需要时间丢数据，没有解决master写的压力。</p>\n<h4>6.4 集群(proxy型)</h4>\n<p>Twemproxy是一个Twitter开源的一个redis和memcache快速/轻量级代理服务器，Twemproxy是一个快速的单线程代理程序，支持Memcached ASCII协议和redis协议。</p>\n<p>特点：</p>\n<ol>\n<li>多种hash算法：MD5、CRC16、CRC32、CRC32a、hsieh、murmur、Jenkins。</li>\n<li>支持失败节点自动删除。</li>\n<li>后端Sharding分配逻辑对业务透明，业务方的读写方式和操作单个Redis一致。</li>\n</ol>\n<p>缺点：增加了新的proxy，需要维护其高可用。failover逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预。</p>\n<h4>6.5 集群(直连型)</h4>\n<p>从redis3.0之后版本支持redis-cluster集群，redis-cluster采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其它所有节点连接。</p>\n<p>特点：</p>\n<ol>\n<li>无中心架构(不存在哪个节点影响性能瓶颈)，少了proxy层。</li>\n<li>数据按照slot存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>\n<li>可扩展性，可线性扩展到1000个节点，节点可动态添加或删除。</li>\n<li>高可用性，部分节点不可用时，集群仍可用。通过增加Slave做备份数据副本。</li>\n<li>实现故障自动failover，节点之间通过gossip协议交换状态信息，用投票机制完成Slave到Master的角色提示。</li>\n</ol>\n<p>缺点：</p>\n<ol>\n<li>资源隔离性较差，容易出现相互影响的情况。</li>\n<li>数据通过异步复制，不保证数据的强一致性。</li>\n</ol>\n<p><a href=\"https://www.cnblogs.com/lpfuture/p/5796398.html\" target=\"_blank\" rel=\"noopener\">一致性哈希算法</a></p>\n<p>添加节点：</p>\n<p>集群创建成功后可以向集群中添加节点，如添加7007节点，执行命令：./redis-trib.rb add-node 127.0.01:7007&nbsp;</p>\n<p>查看</p>\n<h3>七、Redis大key问题</h3>\n<h4>7.1 什么是Redis大key</h4>\n<ol>\n<li>单个key存储的value很大。</li>\n<li>hash、set、zset、list结构中存储过多的元素。</li>\n</ol>\n<h4>7.2 可能存在Redis大key的业务场景</h4>\n<ol>\n<li>配送范围特别大的门店。</li>\n<li>促销活动特别多的门店、商家等。</li>\n<li>高频用户下的订单列表。</li>\n</ol>\n<h4>7.3 Redis大key的危害</h4>\n<p>OPS低也会导致内存占用多、流量大。比如一次取走100K的数据，当OPS为1000时，就会产生100M/s的流量。如果为list、hash等数据结构，大量的elements需要多次遍历，多次系统调用拷贝数据消耗时间。主动删除、被动过期删除、数据迁移等，由于处理这一个key时间长，导致服务器发送阻塞。</p>\n<h4>7.4 如何找出Redis大key</h4>\n<p>redis可使用redis-cli的&ldquo;--bigkeys&rdquo;选项查找大key。</p>\n<p>jimdb管理端，拓扑Tab页，点击实例可以使用Redis大key扫描功能，该功能底层使用scan扫描所有key，会影响实例性能，选择在业务低峰进行。</p>\n<h4>7.5 如何解决Redis大key问题</h4>\n<p>对于需要整取value的大key，可以尝试将对象分拆成几个key-value，使用multiGet获取值，这样分拆的意义在于分拆单次操作的压力，将操作压力平铺到多个实例中，降低对单个实例的IO影响。</p>\n<p>对于每次需要取部分value的大key，同样可以拆成几个key-value，也可以将这些存储在一个hash中，每个field代表具体属性，使用hget、hmget来获取部分value，使用hset、hmset来更新部分属性。</p>\n<p>对于value中存储过多元素的key，同样可以将这部分元素拆分。</p>\n<p>示例：可以固定一个桶数量，比如1W，每次存取的时候，先在本地计算field的hash值，对1W取模，确定field落在哪个key上。</p>\n<pre class=\"language-java\"><code>newHashKey = hashKey + (hash(field) % 10000);\nhset(newHashKey, field, value);\nhget(newHashKey, field);</code></pre>\n<p><a href=\"https://www.cnblogs.com/xgqfrms/p/13601959.html\" target=\"_blank\" rel=\"noopener\">参考文章</a></p>\n<p>&nbsp;</p>\n    </div>\n</template>\n\n<script>\nimport Util from '@/libs/util';\nexport default {\n    methods: {\n        print() {\n            Util.print();\n        }\n    }\n}\n</script>","import mod from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/index.js??vue-loader-options!./redis.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/index.js??vue-loader-options!./redis.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./redis.vue?vue&type=template&id=5d4a768d&\"\nimport script from \"./redis.vue?vue&type=script&lang=js&\"\nexport * from \"./redis.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/_vue-loader@15.9.6@vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}