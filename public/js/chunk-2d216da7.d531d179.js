(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d216da7"],{c3de:function(e,t,a){"use strict";a.r(t);var n=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{staticClass:"suyan__home"},[a("h1",[e._v("Java基础"),a("el-button",{staticClass:"suyan__btn__print",attrs:{type:"primary",plain:""},on:{click:e.print}},[e._v("打印pdf")]),a("el-button",{staticClass:"suyan__btn__close",staticStyle:{"margin-right":"20px"},attrs:{plain:""},on:{click:e.closeAside}},[e._v("关闭导航")])],1),a("el-divider"),a("h3",[e._v("一、什么是阻塞？什么是非阻塞？")]),e._m(0),a("h3",[e._v("二、什么是阻塞IO？什么是非阻塞IO？")]),a("p",[e._v("通常来说，IO操作包括：对硬盘的读写、对socket的读写以及外设的读写。当用户线程发起一个IO请求操作，内核会去查看要读取的数据是否就绪，对于阻塞IO来说，如果数据没有就绪，则会一直在那等待，直到数据就绪；对于非阻塞IO来说，如果数据没有就绪，则会返回一个标志信息告知用户线程当前要读的数据没有就绪。当数据就绪之后，便将数据拷贝到用户线程，这样才完成了一个完整的IO读请求操作，也就是说一个完整的IO读请求操作包括两个阶段：")]),e._m(1),a("p",[e._v("那么阻塞(blocking IO)和非阻塞(non-blocking IO)的区别就在于第一阶段如果数据没有就绪，在查看数据是否就绪的过程中是一直等到，还是直接返回一个标志信息。Java中传统的IO都是阻塞IO，比如通过socket来读取数据，调用read()方法之后，如果数据没有就绪，当前线程就会一直阻塞在read()方法调用那里，直到有数据才返回；而如果是非阻塞IO的话，当数据没有就绪，read()方法应该返回一个标志，告知当前线程数据没有就绪，而不是一直在那里等待。")]),a("h3",[e._v("三、什么是同步IO？什么是异步IO？")]),a("p",[e._v("在《Unix网络编程》一书中同步IO和异步IO的定义是这样的：同步IO即如果一个线程请求进行IO操作，在IO操作完成之前，该线程会被阻塞；而异步IO为如果一个线程请求进行IO操作，IO操作不会导致请求线程被阻塞。")]),a("p",[e._v("事实上，同步IO和异步IO模型是针对用户线程和内核的交互来说的：")]),e._m(2),a("p",[e._v("这是同步IO和异步IO关键区别所在，同步IO和异步IO的关键区别反映在数据拷贝阶段是由用户线程完成还是内核完成。所以说异步IO必须要有操作系统的底层支持。")]),a("h3",[e._v("四、五种IO模型")]),a("h4",[e._v("4.1 阻塞IO模型")]),a("p",[e._v("最传统的一种IO模型，即在读写数据过程中会发生阻塞现象。当用户线程发出IO请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才会解除block状态。")]),a("h4",[e._v("4.2 非阻塞IO模型")]),a("p",[e._v("当用户线程发起一个read操作后，并不需要等待，而是马上就得到一个结果。如果结果是一个error时，它就知道数据还没有准备好，于是它可以再次发生read操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞IO不会交出CPU，而会一直占用CPU。")]),a("h4",[e._v("4.3 多路复用IO模型")]),a("p",[e._v("多路复用IO模型是目前使用比较多的模型，Java NIO实际上就是多路复用IO。在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态，只有当socket真正有读写时间时，才真正调用实际的IO读写操作。因为多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket读写事件进行时，才会使用IO资源，所以它大大减少了资源占用。")]),a("p",[e._v("另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态时通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用线程要高的多。不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。")]),a("h4",[e._v("4.4 信号驱动IO模型")]),a("p",[e._v("在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。")]),a("h4",[e._v("4.5 异步IO模型")]),a("p",[e._v("异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面从内核的角度，当它受到一个asynchronous read之后，它会立刻返回，说明read请求已经成功发送了，因此不会对用户线程产生任何block。然后内核会等待数据准备完成，将数据拷贝到用户线程。当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了。也就说用户线程完全不需要实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。")]),e._m(3),a("p",[e._v("前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。")]),e._m(4),a("h3",[e._v("五、BIO、NIO、AIO")]),a("h4",[e._v("5.1 BIO")]),a("p",[e._v("概念：指阻塞式IO通信模式。每建立一个Socket连接时，同时创建一个新线程对该Socket进行单独通信(采用阻塞的方式通信)。这种方式具有很高的响应速度，并且控制起来也很简单，在连接数较少的时候非常有效，但是如果对每一个连接都产生一个线程无疑是对系统资源的一种浪费，如果连接数较多将会出现资源不足的情况。")]),a("p",[e._v("特点：1、使用一个独立的线程维护一个Socket连接，随着连接数量增多，对虚拟机造成一定的压力；2、使用流来读取数据，流是阻塞的，当没有可读/可写数据时，线程等待，会造成资源的浪费。")]),a("h4",[e._v("5.2 NIO")]),a("p",[e._v("概念：指非阻塞式IO通信模式，Java1.4引入的java.nio包。针对于BIO的两个特点，其实也是缺点，Java提供了NIO通信模式的实现。相对于BIO来说，NIO模式即非阻塞IO。服务器端保存一个Socket连接列表，然后对这个列表进行轮询，如果发现某个Socket端口上有数据可读时(读就绪)，则调用该Socket连接的相应读操作；如果发现某个Socket端口上有数据可写时(写就绪)，则调用该Socket连接的相应写操作；如果某个端口的Socket连接已经中断，则调用相应的析构方法关闭该端口。这样能充分利用服务器资源，效率得到了很大提高。Java中使用Selector、Channel、Buffer来实现上述效果。线程中包含一个Selector对象，它相当于一个通道管理器，可以实现在一个单独线程中处理多个通道的目的，减少线程的创建数量。远程连接对应一个channel，数据的读写通过buffer均在同一个channel中完成，并且数据的读写是非阻塞的。通道创建后需要注册在Selector中，同时需要为该通道注册感兴趣事件(客户端连接服务端事件，服务端接收客户端连接事件、读事件、写事件)，Selector线程需要采用轮询的方式调用Selector的select函数，直到所有注册通道中有兴趣的事件发生则返回，否则一直阻塞。而后循环处理所有就绪的感兴趣事件。以上步骤解决BIO的两个瓶颈：1、不必对每个连接分别创建线程；2、数据读写非阻塞。Java NIO由以下三个核心部分组成：")]),e._m(5),a("p",[e._v("特点：1、一个线程可以处理多个通道，减少线程创建数量；2、读写非阻塞，节约资源：没有可读/可写数据时，不会发生阻塞导致线程资源的浪费。")]),a("h4",[e._v("5.3 AIO")]),a("p",[e._v("概念：指异步非阻塞IO，是Java1.7之后引入的包，是NIO的升级版本，提供了异步非阻塞的IO操作方式，所以叫它AIO(Asynchronous IO)。异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。")]),e._m(6),a("p"),a("p"),a("p"),a("p"),a("p")],1)},r=[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[e._v("阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足。")]),a("li",[e._v("非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需求的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ol",[a("li",[e._v("查看数据是否就绪。")]),a("li",[e._v("进行数据拷贝(内核将数据拷贝到用户线程)。")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ul",[a("li",[e._v("同步IO：当用户发出IO请求操作之后，如果数据没有就绪，需要通过用户线程或者内核不断地去轮询数据是否就绪，当数据就绪时，在将数据从内核拷贝到用户线程。")]),a("li",[e._v("异步IO：只有IO请求操作的发出是由用户线程来进行的，IO操作的两个阶段都是由内核自动完成，然后发送通知告知用户线程IO操作已经完成。也就是说在异步IO中，不会对用户线程产生任何阻塞。")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[e._v("也就是说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用IO函数进行具体的读写。这点和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号标识IO操作完成，不需要在用户线程中调用IO函数进行实际的读写操作。"),a("span",{staticStyle:{color:"#34495e"}},[a("em",[e._v("异步IO操作是需要操作系统的底层支持，在Java7中，提供了Asynchronous IO。")])])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("a",{attrs:{href:"https://blog.yoodb.com/yoodb/article/detail/1498",target:"_blank",rel:"noopener"}},[e._v("参考文章")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ol",[a("li",[e._v("Selector：运行单线程处理多个Channel，如果你的应用打开了多个连接(通道)，但每个连接的流量都很低，使用Selector就会很方便。要使用Selector，得向Selector注册Channel，然后调用它的select方法，这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。")]),a("li",[e._v("Channel与buffer：基本上所有的IO在NIO中都从一个Channel开始，Channel有点像流。数据可以从Channel读取buffer，也可以从buffer写到Channel。Java NIO中的一些主要Channel实现：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，这些通道涵盖了UDP和TCP网络IO以及文件IO。Java NIO中关键的buffer实现：ByteBuffer、CharBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer。")])])},function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("p",[a("a",{attrs:{href:"https://blog.csdn.net/u013177446/article/details/65936341",target:"_blank",rel:"noopener"}},[e._v("参考文章")]),e._v(" "),a("a",{staticStyle:{"margin-left":"20px"},attrs:{href:"http://ifeve.com/overview/",target:"_blank",rel:"noopener"}},[e._v("Java NIO系列教程")]),e._v(" "),a("a",{staticStyle:{"margin-left":"20px"},attrs:{href:"https://www.imooc.com/article/265871",target:"_blank",rel:"noopener"}},[e._v("深入理解BIO、NIO、AIO")])])}],I=a("c276"),O={methods:{print:function(){I["a"].print()},closeAside:function(){I["a"].closeAside()}}},l=O,c=a("5d22"),o=Object(c["a"])(l,n,r,!1,null,null,null);t["default"]=o.exports}}]);
//# sourceMappingURL=chunk-2d216da7.d531d179.js.map